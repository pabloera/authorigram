#!/usr/bin/env python3
"""
Script de Valida√ß√£o de Configura√ß√µes Enhanced Consolidadas v4.9.8
================================================================

Valida se todas as configura√ß√µes enhanced consolidadas est√£o funcionando corretamente,
testando o carregamento de configura√ß√µes por stage e inicializa√ß√£o dos componentes.

üîß CONSOLIDA√á√ÉO: Valida√ß√£o do sistema unificado (base.py + cost_monitor.py)
‚úÖ TESTES: Carregamento de configs, inicializa√ß√£o de componentes, fallbacks
üéØ MONITORAMENTO: Custos e performance por stage
üì¶ ENHANCED: Sistema enhanced integrado nos arquivos originais
"""

import logging
import sys
from pathlib import Path
from typing import Any, Dict, List

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

# Encontrar raiz do projeto
script_dir = Path(__file__).parent
project_root = script_dir.parent
sys.path.insert(0, str(project_root / "src"))

def test_enhanced_loader():
    """Testa o carregamento do EnhancedConfigLoader consolidado"""
    logger.info("üß™ Testando EnhancedConfigLoader consolidado...")
    
    try:
        from anthropic_integration.base import get_enhanced_config_loader, load_operation_config
        
        # Testar singleton
        loader1 = get_enhanced_config_loader()
        loader2 = get_enhanced_config_loader()
        
        if loader1 is not loader2:
            logger.error("‚ùå Singleton pattern falhou")
            return False
            
        logger.info("‚úÖ Singleton pattern funcionando")
        
        # Testar carregamento de stages
        test_operations = [
            'political_analysis',
            'sentiment_analysis', 
            'network_analysis',
            'qualitative_analysis',
            'pipeline_review',
            'topic_interpretation',
            'validation'
        ]
        
        for operation in test_operations:
            try:
                config = load_operation_config(operation)
                if 'model' not in config:
                    logger.error(f"‚ùå Configura√ß√£o inv√°lida para {operation}: falta 'model'")
                    return False
                logger.info(f"‚úÖ {operation}: {config.get('model', 'N/A')}")
            except Exception as e:
                logger.error(f"‚ùå Erro ao carregar config para {operation}: {e}")
                return False
        
        logger.info("‚úÖ EnhancedConfigLoader consolidado validado com sucesso")
        return True
        
    except ImportError as e:
        logger.error(f"‚ùå Erro de importa√ß√£o: {e}")
        return False
    except Exception as e:
        logger.error(f"‚ùå Erro inesperado: {e}")
        return False

def test_anthropic_base():
    """Testa inicializa√ß√£o do AnthropicBase com enhanced config"""
    logger.info("üß™ Testando AnthropicBase com enhanced config...")
    
    try:
        from anthropic_integration.base import AnthropicBase
        
        # Testar inicializa√ß√£o sem stage_operation
        base1 = AnthropicBase()
        logger.info(f"‚úÖ AnthropicBase sem stage: {getattr(base1, 'model', 'N/A')}")
        
        # Testar inicializa√ß√£o com stage_operation
        base2 = AnthropicBase(stage_operation="political_analysis")
        logger.info(f"‚úÖ AnthropicBase com political_analysis: {getattr(base2, 'model', 'N/A')}")
        
        # Verificar se enhanced config foi carregada
        if hasattr(base2, 'enhanced_config') and base2.enhanced_config:
            logger.info("‚úÖ Enhanced config carregada com sucesso")
        else:
            logger.warning("‚ö†Ô∏è Enhanced config n√£o carregada (usando fallback)")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao testar AnthropicBase: {e}")
        return False

def test_component_initialization():
    """Testa inicializa√ß√£o dos componentes principais"""
    logger.info("üß™ Testando inicializa√ß√£o de componentes...")
    
    test_config = {
        'anthropic': {
            'api_key': '${ANTHROPIC_API_KEY}',
            'model': 'claude-3-5-sonnet-20241022'
        }
    }
    
    components_to_test = [
        ('PoliticalAnalyzer', 'political_analyzer'),
        ('AnthropicSentimentAnalyzer', 'sentiment_analyzer'),
        ('SmartPipelineReviewer', 'smart_pipeline_reviewer'),
        ('TopicInterpreter', 'topic_interpreter'),
        ('CompletePipelineValidator', 'pipeline_validator'),
        ('QualitativeClassifier', 'qualitative_classifier'),
        ('IntelligentNetworkAnalyzer', 'intelligent_network_analyzer')
    ]
    
    success_count = 0
    
    for class_name, module_name in components_to_test:
        try:
            module = __import__(f'anthropic_integration.{module_name}', fromlist=[class_name])
            component_class = getattr(module, class_name)
            
            # Inicializar componente
            if class_name == 'CompletePipelineValidator':
                component = component_class(test_config, str(project_root))
            else:
                component = component_class(test_config)
            
            # Verificar se enhanced config foi aplicada
            model = getattr(component, 'model', 'N/A')
            logger.info(f"‚úÖ {class_name}: {model}")
            success_count += 1
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao inicializar {class_name}: {e}")
    
    logger.info(f"‚úÖ {success_count}/{len(components_to_test)} componentes inicializados com sucesso")
    return success_count == len(components_to_test)

def test_cost_monitor():
    """Testa o sistema de monitoramento de custos consolidado"""
    logger.info("üß™ Testando sistema de monitoramento de custos...")
    
    try:
        from anthropic_integration.cost_monitor import get_cost_monitor
        
        # Inicializar cost monitor
        monitor = get_cost_monitor(project_root)
        
        # Testar registro de uso
        cost = monitor.record_usage(
            model="claude-3-5-sonnet-20241022",
            input_tokens=100,
            output_tokens=50,
            stage="test_stage",
            operation="validation"
        )
        
        if cost > 0:
            logger.info(f"‚úÖ Custo calculado: ${cost:.6f}")
        else:
            logger.warning("‚ö†Ô∏è Custo calculado como 0")
        
        # Testar relat√≥rio
        report = monitor.get_daily_report()
        logger.info(f"‚úÖ Relat√≥rio di√°rio gerado: {report.get('total_cost', 0):.6f} USD")
        
        # Testar auto-downgrade
        should_downgrade = monitor.should_auto_downgrade()
        logger.info(f"‚úÖ Auto-downgrade: {'Ativo' if should_downgrade else 'Inativo'}")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao testar cost monitor: {e}")
        return False

def test_fallback_strategies():
    """Testa estrat√©gias de fallback"""
    logger.info("üß™ Testando estrat√©gias de fallback...")
    
    try:
        from anthropic_integration.base import get_enhanced_config_loader
        
        loader = get_enhanced_config_loader()
        
        # Testar fallbacks para diferentes modelos
        test_models = [
            "claude-sonnet-4-20250514",
            "claude-3-5-sonnet-20241022", 
            "claude-3-5-haiku-20241022"
        ]
        
        for model in test_models:
            fallbacks = loader.get_fallback_models(model)
            if fallbacks:
                logger.info(f"‚úÖ Fallbacks para {model}: {', '.join(fallbacks)}")
            else:
                logger.warning(f"‚ö†Ô∏è Nenhum fallback para {model}")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao testar fallbacks: {e}")
        return False

def test_performance_modes():
    """Testa modos de performance"""
    logger.info("üß™ Testando modos de performance...")
    
    try:
        from anthropic_integration.base import get_enhanced_config_loader
        
        loader = get_enhanced_config_loader()
        
        # Testar diferentes opera√ß√µes (j√° que performance modes espec√≠ficos n√£o est√£o implementados)
        test_operations = ['political_analysis', 'sentiment_analysis', 'network_analysis']
        
        for operation in test_operations:
            config = loader.get_stage_config(loader.get_stage_from_operation(operation))
            model = config.get('model', 'N/A')
            logger.info(f"‚úÖ Opera√ß√£o {operation}: {model}")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao testar configura√ß√µes por opera√ß√£o: {e}")
        return False

def run_validation_suite():
    """Executa suite completa de valida√ß√£o"""
    logger.info("üöÄ Iniciando valida√ß√£o completa do sistema enhanced...")
    
    tests = [
        ("Enhanced Loader", test_enhanced_loader),
        ("Anthropic Base", test_anthropic_base),
        ("Component Initialization", test_component_initialization),
        ("Cost Monitor", test_cost_monitor),
        ("Fallback Strategies", test_fallback_strategies),
        ("Configuration per Operation", test_performance_modes)
    ]
    
    passed = 0
    total = len(tests)
    
    for test_name, test_func in tests:
        logger.info(f"\n{'='*50}")
        logger.info(f"üß™ TESTE: {test_name}")
        logger.info('='*50)
        
        try:
            if test_func():
                logger.info(f"‚úÖ {test_name}: PASSOU")
                passed += 1
            else:
                logger.error(f"‚ùå {test_name}: FALHOU")
        except Exception as e:
            logger.error(f"‚ùå {test_name}: ERRO - {e}")
    
    # Relat√≥rio final
    logger.info(f"\n{'='*50}")
    logger.info("üìä RELAT√ìRIO FINAL DE VALIDA√á√ÉO")
    logger.info('='*50)
    logger.info(f"‚úÖ Testes passaram: {passed}/{total}")
    logger.info(f"‚ùå Testes falharam: {total - passed}/{total}")
    logger.info(f"üìà Taxa de sucesso: {(passed/total)*100:.1f}%")
    
    if passed == total:
        logger.info("üéâ TODAS AS VALIDA√á√ïES PASSARAM!")
        logger.info("‚úÖ Sistema enhanced est√° funcionando corretamente")
        logger.info("")
        logger.info("üìã Pr√≥ximos passos:")
        logger.info("1. Execute o pipeline: poetry run python run_pipeline.py")
        logger.info("2. Monitore logs para enhanced config loading")
        logger.info("3. Verifique relat√≥rios de custo em logs/")
        return True
    else:
        logger.error("‚ö†Ô∏è ALGUMAS VALIDA√á√ïES FALHARAM!")
        logger.error("‚ùå Sistema enhanced precisa de corre√ß√µes")
        return False

def main():
    """Fun√ß√£o principal"""
    try:
        return run_validation_suite()
    except KeyboardInterrupt:
        logger.info("\n‚èπÔ∏è Valida√ß√£o interrompida pelo usu√°rio")
        return False
    except Exception as e:
        logger.error(f"‚ùå Erro cr√≠tico durante valida√ß√£o: {e}")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)